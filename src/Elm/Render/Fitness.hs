{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}

module Elm.Render.Fitness
  ( renderFitnessPage,
  )
where

import qualified Data.Set as S
import qualified Data.Text as T
import Data.Time.Calendar.WeekDate
import Data.Time.Clock (UTCTime (..))
import Fitness.Garmin
import Fitness.Utils
import PyF (fmt)

renderFitnessPage :: UTCTime -> [Activity] -> IO T.Text
renderFitnessPage currentTime activities' = do
  let (year, week, _) = toWeekDate (getPstDay currentTime)
  pure $ render $ getByYearAndWeek year week (mapWithDay activities')
  where
    render :: [(Int, [Activity])] -> T.Text
    render activitiesByDay =
      [fmt|\
-- Autogenerated from src/Elm/Render/Fitness.hs
module Fitness.Autogen.Fitness exposing (view)

import Plotting.BarCharts exposing (stackedBarChart)
import Css exposing (..)
import Html.Styled exposing (..)
import Html.Styled.Attributes exposing (class, css, href, src)
import Html.Styled.Events exposing (onClick)

selector =
  div
  [ css
    [ position absolute
    , left (px 205)
    , bottom (px -200)
    ]
  ]
  [ select []
    [ option [] [ text "A" ]
    , option [] [ text "B" ]
    , option [] [ text "C" ]
    , option [] [ text "D" ]
    ]
  ]

view : Html msg
view =
  div
  [ class "container" ]
  [ h1 [ css
        [ textAlign center
        , padding (px 20)
        ]
      ] [ text "{show $ getPstDay currentTime}" ]
  , fromUnstyled <|
     stackedBarChart
       (List.map .day data)
       (List.map (\\{{ label, accessor }} -> ( label, List.map accessor data )) series)
  , form
    [ css [ padding (px 20)] ]
    [ select  []
      [ option [] [ text "A" ]
      , option [] [ text "B" ]
      , option [] [ text "C" ]
      , option [] [ text "D" ]
      ]
    ]
  ]

type alias {workoutTypeName} =
  {{ day : Int
  , {typeMembers}
  }}

series : List {{ label : String, accessor : {workoutTypeName} -> Float }}
series =
  [ {(T.intercalate "\n  , " (toAccessor <$> sportNames))}
  ]

data =
  [ {T.intercalate "\n  , " (uncurry writeData <$> activitiesByDay)}
  ]

|]
      where
        writeData :: Int -> [Activity] -> T.Text
        writeData day activities =
          [fmt|{workoutTypeName} {day} {T.intercalate " " timeDoingSports}|]
          where
            timeDoingSports :: [T.Text]
            timeDoingSports = timeDoingSport <$> S.toList sports
            timeDoingSport :: Sport -> T.Text
            timeDoingSport sport' =
              let f = (\t a -> t + if sport' == sport a then totalActivityTime a else 0)
               in [fmt|{foldl f 0 activities / 3600 :.2}|]
        toAccessor :: T.Text -> T.Text
        toAccessor name = [fmt|{{label = "{name}", accessor = .{T.toLower name}}}|]
        workoutTypeName :: T.Text
        workoutTypeName = "Workout"
        typeMembers :: T.Text
        typeMembers = T.intercalate ": Float \n  , " (T.toLower <$> sportNames) <> ": Float"
        -- This is the set of all @Sport@ seen during this week.
        -- TODO: change this from minBound to maxBound
        sports :: S.Set Sport
        sports =
          let allActivities = concat $ snd <$> activitiesByDay
           in S.fromList $ sport <$> allActivities
        sportNames = T.pack . show <$> S.toList sports
